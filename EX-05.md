#### Q1. Using List Comprehension, give an expression that calculates the sum of first 100 integer squares.

---

#### Ans.

```haskell
sum[x*x | x <- [1..100]]

```

#### Q2. In a similiar way to the function length, show how the library function replicate:: Int -> a -> [a] that produces a list of identical elements can be define using a list comprehesnsion.

---

#### Ans.

```haskell

Prelude> :{
Prelude| replicate :: Int -> a -> [a]
Prelude| replicate n value = [value | _ <-[1..n]] 
Prelude| :}

```


#### Q3. A triple (x,y,z) of positive integers is pythagorean if x^2+y^2=z^2. Using a list comprehension, define a function pyths:: Int -> [(Int,Int,Int)] that returns the list of all pythagorean triples whose components are at most given limit. For example:

```
pyths 10
[(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]
```

---

#### Ans.

```haskell

Prelude> :{
Prelude| pyths :: Int -> [(Int,Int,Int)]
Prelude| pyths n = [(x,y,z) | x<-[1..n], y<-[1..n], z<-[1..n], ((x*x)+(y*y)==(z*z))]
Prelude| :}

```

#### Q4. A positive integer is perfect if it equals the sum of its factors, excluding the number itself. Using a list comprehension and the function factors, define a function perfects::Int->[Int] that returns the list of all perfect numbers up to a given limit. For example:

```
perfect 500
[6, 28, 496]
```

---

#### Ans.


```haskell
Prelude> :{
Prelude| factors :: Int -> [Int]
Prelude| factors n = [x | x <- [1..n-1], (n `mod` x == 0) ]
Prelude| isPerfect :: Int -> Bool
Prelude| isPerfect n = ((sum (factors n)) == n)
Prelude| perfects :: Int -> [Int]
Prelude| perfects n = [x | x <- [1..n] , isPerfect x]
Prelude| :}
```

#### Q5. Show how the single comprehension [(x,y) | x <- [1,2,3], y <- [4,5,6]] with two generators can be re-expressed using two comprehensions with single generators. Hint: make use of the library function concat and nest one comprehension within the other.


---

#### Ans.



