#### Q1. Show how the list comprehension [f x | x <- xs, p x] can be re-expressed using the higher-order functions map and filter.

---

#### Ans.

```haskell
map(f x) (filter p xs) 

```

#### Q2. Without looking at the definitions from the standard prelude, define the higher-order functions all, any, takeWhile and dropWhile.

---

#### Ans.

**all**

##### Simple Recursion

```haskell
 :{
Prelude| all :: (a->Bool) -> [a] -> Bool
Prelude| all f [] = True
Prelude| all f (a:as) = f a && all f as
Prelude| :}

```

##### Using Foldr

```haskell
all f = foldr(\a b  -> (b && (f a)) ) True

```


**suppose f is defined as**
```haskell
Prelude| even :: Int -> Bool
Prelude| even n = if n `mod` 2 ==0 then True else False
Prelude| :}
Prelude> 
``` 

```haskell
Prelude>all even [1,2,3,4]
False
Prelude> all even [2,4]
True
Prelude> all even [2,4,6]

```

**any**

##### Simple recursion

```haskell
:{
Prelude| any :: (a->Bool) -> [a] -> Bool
Prelude| any f [] = False
Prelude| any f (a:as) = f a || any f as
Prelude| :}
```

##### Using Foldr

```haskell

any f = foldr(\a b  -> (b || (f a)) ) False

```

**takeWhile**

##### Simple Recursion

```haskell
 :{
Prelude| takeWhile f [] = "" 
Prelude| takeWhile f (a:as) = if f a then a:(takeWhile f as) else ""
Prelude| :}
```

##### Using foldr

```haskell

takeWhile f = foldr(\a as -> if (f a) then a:as else "" ) ""

```

**dropWhile**



```haskell
:{
Prelude Data.Char| dropWhile f [] = [] 
Prelude Data.Char| dropWhile f (x:xs) = if (not (f x)) then (x:xs) else dropWhile f xs
Prelude Data.Char| :}


```


##### Using foldr

--TODO--


##### Q3. define map and filter using foldr

```haskell
filter' f =  foldr(\x xs -> if (f x) then x:xs else xs)[]
```

```haskell
map' f = foldr (\x xs -> f x : xs) []
```

##### Q4. Using foldl define a function dec2int :: [Int]-> Int that converts a decimal number into an integer. For example:

>dec2int[2,3,4,5] <br/>
2345


##### Ans.

```haskell
:{
Prelude Data.Char| dec2Int:: [Int]->Int
Prelude Data.Char| dec2Int = foldl(\a b -> (a*10+b))  0
Prelude Data.Char| :}

```


##### Q5.Explain why the following definition is invalid:

```haskell
sumsqreven = compose[sum,map(^2),filter even]

```

##### Ans.

```
there is no function like compose in haskell. Correct definition should be written as following where . operator is used for composing two function.

```

<br/>

```haskell

sumsqreven = sum . map (^2). filter even
```


##### Q6. Without looking at the standard prelude, define the higher-order library function curry that converts a function on pairs into a curried function. and , conversely the function uncurry that converts a curried function with two arguments into a function on pairs.

**Hint : First write down the types of the two functions.**

##### Ans.

```haskell
type Bit = Int                                                                                                                                                                
unfold p h t x | p x = []                                                                 
               | otherwise = h x : unfold p h t (t x)                                     
                                                                                           
                                                                                           
                                                                                           
int2bin = unfold(== 0)(`mod` 2)(`div` 2)                                                  
                                                                                           
chop_8 = unfold(null )(take 8 )(drop 8)                                                    
                                                                                           
map1 f = unfold (null) (f.head) (tail) 


```
